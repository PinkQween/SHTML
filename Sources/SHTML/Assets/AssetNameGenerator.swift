import Foundation

/// Generates typed `ImageName` and `FontName` extension files from asset folders.
public enum AssetNameGenerator {
    private static let imageExtensions: Set<String> = [
        "png", "jpg", "jpeg", "webp", "gif", "svg", "avif", "bmp", "tif", "tiff"
    ]
    private static let fontExtensions: Set<String> = [
        "ttf", "otf", "woff", "woff2", "eot"
    ]
    private static let videoExtensions: Set<String> = [
        "mp4", "webm", "ogg", "mov", "m4v"
    ]
    private static let audioExtensions: Set<String> = [
        "mp3", "wav", "ogg", "m4a", "aac", "flac"
    ]
    private static let swiftKeywords: Set<String> = [
        "associatedtype", "class", "deinit", "enum", "extension", "fileprivate", "func", "import",
        "init", "inout", "internal", "let", "open", "operator", "private", "protocol", "public",
        "rethrows", "static", "struct", "subscript", "typealias", "var", "break", "case", "catch",
        "continue", "default", "defer", "do", "else", "fallthrough", "for", "guard", "if", "in",
        "repeat", "return", "throw", "switch", "where", "while", "as", "Any", "false", "is", "nil",
        "self", "Self", "super", "throws", "true", "try", "_", "Type", "Protocol"
    ]

    /// Creates generated symbol files for images and fonts.
    ///
    /// - Parameters:
    ///   - imagesDirectory: Directory containing image files.
    ///   - fontsDirectory: Directory containing font files.
    ///   - outputDirectory: Directory where generated Swift files are written.
    public static func generate(
        imagesDirectory: String = "Assets/Images",
        videosDirectory: String = "Assets/Videos",
        audioDirectory: String = "Assets/Audio",
        fontsDirectory: String = "Assets/Fonts",
        outputDirectory: String = "Sources/App/Generated"
    ) throws {
        let fileManager = FileManager.default
        try fileManager.createDirectory(atPath: outputDirectory, withIntermediateDirectories: true)

        let generatedImageSymbols = try imageSymbols(in: imagesDirectory)
        let generatedVideoSymbols = try videoSymbols(in: videosDirectory)
        let generatedAudioSymbols = try audioSymbols(in: audioDirectory)
        let generatedFontSymbols = try fontSymbols(in: fontsDirectory)

        let imageContents = renderExtension(
            header: "// Generated by SHTML AssetNameGenerator. Do not edit.",
            typeName: "ImageName"
        ) {
            generatedImageSymbols.map {
                "    static let \($0.identifier): ImageName = ImageName(\"\($0.name)\", format: .\($0.extensionCase))"
            }
        }
        let fontContents = renderExtension(
            header: "// Generated by SHTML AssetNameGenerator. Do not edit.",
            typeName: "FontName"
        ) {
            generatedFontSymbols.map {
                "    static let \($0.identifier): FontName = \"\($0.name)\""
            }
        }
        let videoContents = renderExtension(
            header: "// Generated by SHTML AssetNameGenerator. Do not edit.",
            typeName: "VideoName"
        ) {
            generatedVideoSymbols.map {
                "    static let \($0.identifier): VideoName = VideoName(\"\($0.name)\", format: .\($0.extensionCase))"
            }
        }
        let audioContents = renderExtension(
            header: "// Generated by SHTML AssetNameGenerator. Do not edit.",
            typeName: "AudioName"
        ) {
            generatedAudioSymbols.map {
                "    static let \($0.identifier): AudioName = AudioName(\"\($0.name)\", format: .\($0.extensionCase))"
            }
        }

        let imageFile = URL(fileURLWithPath: outputDirectory).appendingPathComponent("ImageName+Generated.swift")
        let fontFile = URL(fileURLWithPath: outputDirectory).appendingPathComponent("FontName+Generated.swift")
        let videoFile = URL(fileURLWithPath: outputDirectory).appendingPathComponent("VideoName+Generated.swift")
        let audioFile = URL(fileURLWithPath: outputDirectory).appendingPathComponent("AudioName+Generated.swift")
        try imageContents.write(to: imageFile, atomically: true, encoding: .utf8)
        try fontContents.write(to: fontFile, atomically: true, encoding: .utf8)
        try videoContents.write(to: videoFile, atomically: true, encoding: .utf8)
        try audioContents.write(to: audioFile, atomically: true, encoding: .utf8)
    }

    private static func imageSymbols(
        in directory: String
    ) throws -> [(identifier: String, name: String, extensionCase: String)] {
        let fileManager = FileManager.default
        guard fileManager.fileExists(atPath: directory) else { return [] }

        let contents = try fileManager.contentsOfDirectory(atPath: directory)
        let entries = contents.compactMap { item -> (name: String, ext: String)? in
            let url = URL(fileURLWithPath: item)
            let ext = url.pathExtension.lowercased()
            guard imageExtensions.contains(ext) else { return nil }
            return (url.deletingPathExtension().lastPathComponent, ext)
        }.sorted { lhs, rhs in
            if lhs.name == rhs.name { return lhs.ext < rhs.ext }
            return lhs.name < rhs.name
        }

        return deduped(entries: entries)
    }

    private static func fontSymbols(
        in directory: String
    ) throws -> [(identifier: String, name: String)] {
        let fileManager = FileManager.default
        guard fileManager.fileExists(atPath: directory) else { return [] }

        let contents = try fileManager.contentsOfDirectory(atPath: directory)
        let names = contents.compactMap { item -> String? in
            let url = URL(fileURLWithPath: item)
            let ext = url.pathExtension.lowercased()
            guard fontExtensions.contains(ext) else { return nil }
            return url.deletingPathExtension().lastPathComponent
        }.sorted()

        var used: Set<String> = []
        return names.map { name in
            var id = swiftIdentifier(from: name)
            if used.contains(id) {
                var n = 2
                while used.contains("\(id)\(n)") { n += 1 }
                id = "\(id)\(n)"
            }
            used.insert(id)
            return (id, name)
        }
    }

    private static func videoSymbols(
        in directory: String
    ) throws -> [(identifier: String, name: String, extensionCase: String)] {
        let fileManager = FileManager.default
        guard fileManager.fileExists(atPath: directory) else { return [] }

        let contents = try fileManager.contentsOfDirectory(atPath: directory)
        let entries = contents.compactMap { item -> (name: String, ext: String)? in
            let url = URL(fileURLWithPath: item)
            let ext = url.pathExtension.lowercased()
            guard videoExtensions.contains(ext) else { return nil }
            return (url.deletingPathExtension().lastPathComponent, ext)
        }.sorted { lhs, rhs in
            if lhs.name == rhs.name { return lhs.ext < rhs.ext }
            return lhs.name < rhs.name
        }

        return deduped(entries: entries)
    }

    private static func audioSymbols(
        in directory: String
    ) throws -> [(identifier: String, name: String, extensionCase: String)] {
        let fileManager = FileManager.default
        guard fileManager.fileExists(atPath: directory) else { return [] }

        let contents = try fileManager.contentsOfDirectory(atPath: directory)
        let entries = contents.compactMap { item -> (name: String, ext: String)? in
            let url = URL(fileURLWithPath: item)
            let ext = url.pathExtension.lowercased()
            guard audioExtensions.contains(ext) else { return nil }
            return (url.deletingPathExtension().lastPathComponent, ext)
        }.sorted { lhs, rhs in
            if lhs.name == rhs.name { return lhs.ext < rhs.ext }
            return lhs.name < rhs.name
        }

        return deduped(entries: entries)
    }

    private static func deduped(
        entries: [(name: String, ext: String)]
    ) -> [(identifier: String, name: String, extensionCase: String)] {
        var grouped: [String: [String]] = [:]
        for entry in entries {
            grouped[entry.name, default: []].append(entry.ext)
        }

        var used: Set<String> = []
        return entries.map { entry in
            let hasCollision = (grouped[entry.name]?.count ?? 0) > 1
            let seed = hasCollision
                ? "\(entry.name)-\(entry.ext)"
                : entry.name
            var id = swiftIdentifier(from: seed)
            if used.contains(id) {
                var n = 2
                while used.contains("\(id)\(n)") { n += 1 }
                id = "\(id)\(n)"
            }
            used.insert(id)
            return (id, entry.name, entry.ext)
        }
    }

    private static func swiftIdentifier(from raw: String) -> String {
        let parts = raw
            .split(whereSeparator: { !$0.isLetter && !$0.isNumber })
            .map(String.init)
            .filter { !$0.isEmpty }

        guard let first = parts.first else { return "asset" }

        let head = first.prefix(1).lowercased() + first.dropFirst()
        let tail = parts.dropFirst().map { part -> String in
            part.prefix(1).uppercased() + part.dropFirst()
        }.joined()

        var identifier = head + tail
        if let firstChar = identifier.first, firstChar.isNumber {
            identifier = "_\(identifier)"
        }
        if swiftKeywords.contains(identifier) {
            return "`\(identifier)`"
        }
        return identifier
    }

    private static func renderExtension(
        header: String,
        typeName: String,
        lines: () -> [String]
    ) -> String {
        let body = lines()
            .joined(separator: "\n")

        return """
        \(header)
        import SHTML

        extension \(typeName) {
        \(body)
        }
        """
    }
}
