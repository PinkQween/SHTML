import Foundation

/// Generates typed `ImageName` and `FontName` extension files from asset folders.
public enum AssetNameGenerator {
    private static let imageExtensions: Set<String> = [
        "png", "jpg", "jpeg", "webp", "gif", "svg", "avif", "bmp", "tif", "tiff"
    ]
    private static let fontExtensions: Set<String> = [
        "ttf", "otf", "woff", "woff2", "eot"
    ]
    private static let swiftKeywords: Set<String> = [
        "associatedtype", "class", "deinit", "enum", "extension", "fileprivate", "func", "import",
        "init", "inout", "internal", "let", "open", "operator", "private", "protocol", "public",
        "rethrows", "static", "struct", "subscript", "typealias", "var", "break", "case", "catch",
        "continue", "default", "defer", "do", "else", "fallthrough", "for", "guard", "if", "in",
        "repeat", "return", "throw", "switch", "where", "while", "as", "Any", "false", "is", "nil",
        "self", "Self", "super", "throws", "true", "try", "_", "Type", "Protocol"
    ]

    /// Creates generated symbol files for images and fonts.
    ///
    /// - Parameters:
    ///   - imagesDirectory: Directory containing image files.
    ///   - fontsDirectory: Directory containing font files.
    ///   - outputDirectory: Directory where generated Swift files are written.
    public static func generate(
        imagesDirectory: String = "Assets/Images",
        fontsDirectory: String = "Assets/Fonts",
        outputDirectory: String = "Sources/App/Generated"
    ) throws {
        let fileManager = FileManager.default
        try fileManager.createDirectory(atPath: outputDirectory, withIntermediateDirectories: true)

        let imageSymbols = try symbols(
            in: imagesDirectory,
            allowedExtensions: imageExtensions
        )
        let fontSymbols = try symbols(
            in: fontsDirectory,
            allowedExtensions: fontExtensions
        )

        let imageContents = renderExtension(
            header: "// Generated by SHTML AssetNameGenerator. Do not edit.",
            typeName: "ImageName",
            symbols: imageSymbols
        )
        let fontContents = renderExtension(
            header: "// Generated by SHTML AssetNameGenerator. Do not edit.",
            typeName: "FontName",
            symbols: fontSymbols
        )

        let imageFile = URL(fileURLWithPath: outputDirectory).appendingPathComponent("ImageName+Generated.swift")
        let fontFile = URL(fileURLWithPath: outputDirectory).appendingPathComponent("FontName+Generated.swift")
        try imageContents.write(to: imageFile, atomically: true, encoding: .utf8)
        try fontContents.write(to: fontFile, atomically: true, encoding: .utf8)
    }

    private static func symbols(
        in directory: String,
        allowedExtensions: Set<String>
    ) throws -> [(identifier: String, value: String)] {
        let fileManager = FileManager.default
        guard fileManager.fileExists(atPath: directory) else { return [] }

        let contents = try fileManager.contentsOfDirectory(atPath: directory)
        let baseNames = contents.compactMap { item -> String? in
            let url = URL(fileURLWithPath: item)
            let ext = url.pathExtension.lowercased()
            guard allowedExtensions.contains(ext) else { return nil }
            return url.deletingPathExtension().lastPathComponent
        }.sorted()

        var used: Set<String> = []
        return baseNames.map { base in
            var id = swiftIdentifier(from: base)
            if used.contains(id) {
                var n = 2
                while used.contains("\(id)\(n)") {
                    n += 1
                }
                id = "\(id)\(n)"
            }
            used.insert(id)
            return (id, base)
        }
    }

    private static func swiftIdentifier(from raw: String) -> String {
        let parts = raw
            .split(whereSeparator: { !$0.isLetter && !$0.isNumber })
            .map(String.init)
            .filter { !$0.isEmpty }

        guard let first = parts.first else { return "asset" }

        let head = first.prefix(1).lowercased() + first.dropFirst()
        let tail = parts.dropFirst().map { part -> String in
            part.prefix(1).uppercased() + part.dropFirst()
        }.joined()

        var identifier = head + tail
        if let firstChar = identifier.first, firstChar.isNumber {
            identifier = "_\(identifier)"
        }
        if swiftKeywords.contains(identifier) {
            return "`\(identifier)`"
        }
        return identifier
    }

    private static func renderExtension(
        header: String,
        typeName: String,
        symbols: [(identifier: String, value: String)]
    ) -> String {
        let body = symbols
            .map { "    static let \($0.identifier): \(typeName) = \"\($0.value)\"" }
            .joined(separator: "\n")

        return """
        \(header)
        import SHTML

        extension \(typeName) {
        \(body)
        }
        """
    }
}
